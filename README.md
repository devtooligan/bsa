# Based Static Analyzer (BSA)

## SUMMARY

**Based Static Analyzer (BSA)** is a static analysis tool designed to detect vulnerabilities and security issues in Solidity smart contracts. It analyzes Abstract Syntax Trees (ASTs) generated by Foundry's `forge` tool, providing a structured output for further processing. Built in Python, BSA emphasizes modularity, extensibility, and rigorous testing to ensure reliability and ease of use within the Solidity development ecosystem.

## ARCHITECTURAL DECISIONS HIGHLIGHTS

- **Parser Choice**:  
  - **Decision**: Use Foundry's `forge build --ast` to generate ASTs.  
  - **Why**: Seamless integration with Foundry, a popular Solidity toolchain, handling dependencies and project structures effectively.  
  - **Alternatives**: Direct use of `solc` was considered but rejected due to its weaker support for project-level features like remappings.

- **Modular Design**:  
  - **Decision**: Split the project into discrete modules (CLI, parser, detectors).  
  - **Why**: Simplifies development, testing, and future extensions by isolating functionality.  
  - **Factors**: Reduces complexity and enables independent work on components.

- **Output Format**:  
  - **Decision**: Structured dictionary for parser output.  
  - **Why**: Simple, flexible format that's easy to parse and extend for downstream analysis.  
  - **Alternatives**: JSON or custom objects were discussed but deemed less straightforward.

- **Testing Strategy**:  
  - **Decision**: Unit tests for each step, integration tests at milestones.  
  - **Why**: Ensures component correctness and system-wide reliability.  
  - **Factors**: Prevents regressions and supports incremental development.

## AST PARSER DOCUMENTATION

### API REFERENCE

The AST parser is invoked via the command:

```bash
python -m bsa <path>
```

`<path>`: Directory of the Foundry project to analyze.

#### Steps Performed:
1. **Clean Project**: Executes `forge clean` to reset the build environment.
2. **Compile and Generate ASTs**: Runs `forge build --ast` to compile Solidity code and output AST JSON files to the `out/` directory.
3. **Parse ASTs**: Processes the generated JSON files, extracting key information.
4. **Output**: Returns a structured dictionary with contract metadata and entrypoint details.

#### Output Structure:
```python
[
    {
        "contract": {
            "name": str,               # Contract name (e.g., "MyContract")
            "pragma": str,             # Solidity pragma (e.g., "^0.8.0")
            "state_vars": [            # List of state variables
                {
                    "name": str,       # Variable name (e.g., "owner")
                    "type": str,       # Type (e.g., "address")
                    "location": [int, int]  # [line, column] in source code
                },
                ...
            ],
            "functions": {             # Dictionary of all functions
                str: {                 # Function name as key
                    "visibility": str, # e.g., "public", "external"
                    "location": [int, int]  # [line, column]
                },
                ...
            },
            "events": [                # List of events
                {
                    "name": str,       # Event name (e.g., "Transfer")
                    "location": [int, int]  # [line, column]
                },
                ...
            ]
        },
        "entrypoints": [            # List of external/public functions
            {
                "name": str,        # Function name (e.g., "transfer")
                "location": [int, int],  # [line, column]
                "calls": [          # Internal function calls
                    {
                        "name": str,    # Called function name
                        "in_contract": bool,  # True if within same contract
                        "location": [int, int]  # [line, column]
                    },
                    ...
                ]
            },
            ...
        ]
    },
    ...
]
```

### ASSUMPTIONS

- **Project Setup**: Assumes a valid Foundry project with a `foundry.toml` configuration file.
- **Source Location**: Expects contract files in the `src/` directory.
- **Single-File Focus**: Processes the first AST file found in `out/`, ignoring others for now.
- **Forge Availability**: Assumes `forge` is installed and accessible in the environment.

These assumptions allow integration without needing to understand the parser's internal workingsâ€”just provide a Foundry project path and handle the output dictionary.

## FUTURE WORK

### APPROACH

Development will proceed with a disciplined, incremental strategy:

- **Discrete Baby Steps**: Each feature or fix is broken into small, well-defined tasks with clear objectives.
- **Unit Tests**: Every step includes unit tests to verify functionality in isolation.
- **Integration Tests**: Conducted at milestones to ensure components work together.
- **Modular Design**: Components remain decoupled, minimizing context needed for an LLM to work on specific parts. This ensures an LLM can focus on one module (e.g., a detector) without understanding the entire system.

### DETAILED PLAN

1. **Static Single Assignment (SSA) Transformation**:  
   - Add SSA conversion for entrypoint function bodies.  
   - Extend output dictionary with SSA data for advanced analysis.

2. **Advanced Vulnerability Detectors**:  
   - Implement detectors for issues like reentrancy and integer overflow.  
   - Leverage SSA and AST data for precise detection.

3. **Multi-File Support**:  
   - Update parser to process multiple AST files from `out/`.  
   - Enable cross-file analysis for broader vulnerability detection.

4. **Tool Integration**:  
   - Add compatibility with tools like Slither or Mythril.  
   - Create APIs or plugins for interoperability.

These milestones provide clear goals that can be broken into baby steps during implementation, requiring no additional context beyond this plan.